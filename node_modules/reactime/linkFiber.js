/* eslint-disable no-underscore-dangle */
/* eslint-disable func-names */
/* eslint-disable no-use-before-define */
/* eslint-disable no-param-reassign */
// links component state tree to library
// changes the setState method to also update our snapshot
const Tree = require('./tree');
const astParser = require('./astParser');
const { saveState } = require('./masterState');

  //* Snap is reference to the snapShot object from index.js
module.exports = (snap, mode) => {
  //* This is the beginning of the body of the function definition that is exported

  let fiberRoot = null;
  let astHooks;
  let concurrent = false; // flag to check if we are in concurrent mode

  function sendSnapshot() {
    // don't send messages while jumping or while paused
    // DEV: So that when we are jumping to an old snapshot it
    // wouldn't think we want to create new snapshots
    if (mode.jumping || mode.paused) return;
    const payload = snap.tree.getCopy();
    // console.log('payload', payload);
    window.postMessage({
      action: 'recordSnap',
      payload,
    });
  }

  function changeSetState(component) {
    // check that setState hasn't been changed yet
    //* This linkedFiberChanged key is added at the end of the body of this function
    //? Is there an alternative, simpler way to check this rather than adding a new property? What else would be unique to a modified setState method?
    if (component.setState.linkFiberChanged) return;
    // make a copy of setState
    //* A copy of setState is made so that we still have access to the original functionality of React setState.
    const oldSetState = component.setState.bind(component);
    //* Bind is necessary so that it maintains its relationship to the component. 
    // ! console.log(component.setState, 'setState Definition')  // Uncomment this line to see the definition of setState

    // replace component's setState so developer doesn't change syntax
    // component.setState = newSetState.bind(component);
    component.setState = (state, callback = () => {}) => {
      //* Callback is anonymous function that returns undefined by default. 
      //? Will this empty annonymous function pass CI testing?  
      // don't do anything if state is locked
      // UNLESS we are currently jumping through time
      if (mode.locked && !mode.jumping) return;
      // continue normal setState functionality, except add sending message middleware
      oldSetState(state, () => {
        //* This anonymous function definition is passed into the original setState method as a callback.
        updateSnapShotTree();
        sendSnapshot();
        //* The snapshotTree is updated and sent before the callback is invoked. 
        callback.bind(component)();
      });
    };
    component.setState.linkFiberChanged = true;
  }

  function changeUseState(component) {
    if (component.queue.dispatch.linkFiberChanged) return;
    // store the original dispatch function definition
    const oldDispatch = component.queue.dispatch.bind(component.queue);
    // redefine the dispatch function so we can inject our code
    component.queue.dispatch = (fiber, queue, action) => {
      // don't do anything if state is locked
      if (mode.locked && !mode.jumping) return;
      oldDispatch(fiber, queue, action);
      // setTimeout(() => {
      updateSnapShotTree();
      sendSnapshot();
      // }, 100);
    };
    component.queue.dispatch.linkFiberChanged = true;
  }

  // Helper function to traverse through the memoized state
  // TODO: WE NEED TO CLEAN IT UP A BIT
  function traverseHooks(memoizedState) {
    // Declare variables and assigned to 0th index and an empty object, respectively
    //* memoized stores each state value
    const memoized = {};
    let index = 0;
    //* astHooks starts as an object with keys representing the useState hook ie: {_useState: "count", _useState2: "setCount"}
    astHooks = Object.values(astHooks);
    //* We take the values of those keys and create an array of all the values. 

    // while memoizedState is truthy, save the value to the object
    while (memoizedState && memoizedState.queue) {
      // prevents useEffect from crashing on load
      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates
      changeUseState(memoizedState);
      // }
      //? Can we remove the comment below since its a duplicate of the code? 
      // memoized[astHooks[index]] = memoizedState.memoizedState;
      //? astHooks seems to traverse in a way similar to this method - is this why the values always match? 
      //? Is there a way to do both traversals simultaneously?
      //* Since astHooks is an array of useState return values and we only want the first element [the current state value] from each instance of useState: 
      
      memoized[astHooks[index]] = memoizedState.memoizedState;
      // Reassign memoizedState to its next value
      //! See note below and check ESLint
      //? We should consider at least reassigning memoizedState to a different variable name by reference. 
      //? Should we create a copy of the memoized state object and then manipulate that version?
      //* The next line is what allows us to traverse to find the next state. 
      memoizedState = memoizedState.next;
      // Increment the index by 2
      //* Since we know that the useState returns an array with 2 values, we increment by 2 to skip to he next instance of useState
      index += 2;
    }
    return memoized;
  }

  function createTree(currentFiber, tree = new Tree('root')) {
    //* When this function is invoked from another function, a new tree is created where the state property of the component key has a key called "root"
    //* The recursive iterations have this tree passed into the recursive functions. 
    //* The recursive runs: 1. Create a tree where the component key is equal to the stateNode. 2. Push that tree into the children array of the original tree 3. Saves the tree that has become a new child as nextTree
    //* This is a recursive function, so adding a console.log here will result in numerous invocations

    //* The next line is the base case for the recursion. If we have reached the linkedList, currentFiber will be null and we can simply return the updated tree that has been updated with all of the children. 
    if (!currentFiber) return tree;

    const {
      sibling,
      stateNode,
      child,
      memoizedState,
      elementType,
    } = currentFiber;
    //* memoizedState is null until numbers are pressed into the calculator. The number in the results window of the calculator is what is memoized.

    //? Why do we rename tree as nextTree, but in the lines below we use both names.
    let nextTree = tree;
    // check if stateful component
    if (stateNode && stateNode.state) {
      //* In the calculator app there is only 1 stateful component, so there is only 1 stateNode that have a value that is not null/undefined.
      // add component to tree
      nextTree = tree.appendChild(stateNode);

      // change setState functionality
      changeSetState(stateNode);
      //? Is there any reason for invoking this function below the invocation of appendChild? 
      //? Is the location interchangable (can be placed at the top of the body if desired)?  
    }
    // Check if the component uses hooks
    // console.log("memoizedState", memoizedState);

    //? It seems that components using the setState method will have stateNodes and functional components using useState will have memoizedState. -
    //? Are there any other properties we can use to determine what hooks / lifecycle methods are in use? Any potential bugs that using these identifiers could cause, or are they 100% accurate?
    if (
      memoizedState &&
      Object.hasOwnProperty.call(memoizedState, 'baseState')
      //* This syntax for object.hasOwnProperty is used to bind the Object prototype's hasOwnProperty method to the memoizedState object and invoke it with an argument of baseState. 
      //? Is there any situation when memoizedState would have a property called hasOwnProperty?
      //? Why do we need to check for a memoizedState key and a baseState property as well?

    ) {
      // 'catch-all' for suspense elements (experimental)
      //? Does this mean that suspense mode is not supported? What other identifiers can we use for suspense elements
      if (typeof elementType.$$typeof === 'symbol') return;
      // Traverse through the currentFiber and extract the getters/setters
      //* ElementType in the calculator after clicking: The function defintion of the functional component with the useState hook.
      //* astHooks is declared in the body of the parent function, and it is used by traverseHooks as well
      //* astHooks is formatted like this: {_useState: "count", _useState2: "setCount", _useState3: "test", _useState4: "test2"} [the return values of useState are stored as the values of the numbered keys. Have to move forward my 2 keys to get the next instance of useState]
      //? Can we refactor by passing necessary information into functions rather than storing them globally for the other methods?
      astHooks = astParser(elementType);
      saveState(astHooks);
      //? Why do we need saveState? It doesn't appear that masterState is used for anything after values are saved into it. 
      // Create a traversed property and assign to the evaluated result of
      // invoking traverseHooks with memoizedState
      //* .traversed has all of the current state values stored inside of an object. 
      memoizedState.traversed = traverseHooks(memoizedState);
      nextTree = tree.appendChild(memoizedState);
    }
    //* First parameter of createTree is the currentFiber. That's why we pass in the sibling or child properties from the currentFiber object. 
    //* The second parameter is the tree which has the children array in the constructor that we will push memoized state etc into. 

    // iterate through siblings
    createTree(sibling, tree);
    // iterate through children
    //? Why do we call it nextTree here as though nextTree is something different as opposed to just calling it tree?
    createTree(child, nextTree);

    return tree;
  }
  // runs when page initially loads
  // but skips 1st hook click
  async function updateSnapShotTree() {
    let current;
    // if concurrent mode, grab current.child'
    if (concurrent) {
      // we need a way to wait for current child to populate
      //? Why is it 400ms?
      const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve(fiberRoot.current.child), 400);
      });

      current = await promise;
      //? It seems like we may not need the lines above this that also assign a value to current.
      current = fiberRoot.current.child;
    } else {
      current = fiberRoot.current;
    }

    //* The fiberNode is passed into createTree as an argument
    //* The return value of createTree is assigned to the snapShot object in index.js
    snap.tree = createTree(current);
  }

  return async container => {
    //* This is the function definition that is returned. 
    //* This function takes 1 argument (called container). The argument is the root HTML element that React attaches itself to. 
    //* For example: const root = document.getElementById('root');

    //! console.log(container._reactRootContainer)
    //? In Concurrent Mode, the instructions say to invoke ReactDOM.createRoot. This would cause the container passed into Reactime to be similar to _reactRootContainer in that it would have an _internalRoot property.
    //? Is this done because it is a technical requirement of concurrent mode, or is it just done so that this if statement can have this particular logic?
    //? If the answer to the second question is yes, we may be able to refactor by adding a second parameter to the function. There may also be another property in _internalRoot that we could use in order to optimize everything.    
    if (container._internalRoot) {
      fiberRoot = container._internalRoot;
      concurrent = true;
    } else {
      const {
        _reactRootContainer: { _internalRoot },
        _reactRootContainer,
      } = container;
      // only assign internal root if it actually exists
      //? What would happen if the internal root didn't exist? Why wouldn't it exist? (do we need the _reactRootContainer part of the OR operator)
      //* fiberRoot is stored at the top of the body of the linkFiber method. We update it every time the function is invoked. 
      fiberRoot = _internalRoot || _reactRootContainer;
    }

    await updateSnapShotTree();
    // send the initial snapshot once the content script has started up
    window.addEventListener('message', ({ data: { action } }) => {
      if (action === 'contentScriptStarted') sendSnapshot();
    });
  };
};
