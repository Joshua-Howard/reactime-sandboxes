/* eslint-disable no-underscore-dangle */
/* eslint-disable func-names */
/* eslint-disable no-use-before-define */
/* eslint-disable no-param-reassign */
// links component state tree to library
// changes the setState method to also update our snapshot
const Tree = require('./tree');
const astParser = require('./astParser');
const { saveState } = require('./masterState');

  //* Snap is reference to the snapShot object from index.js
module.exports = (snap, mode) => {
  //* This is the beginning of the body of the function definition that is exported

  let fiberRoot = null;
  let astHooks;
  let concurrent = false; // flag to check if we are in concurrent mode

  function sendSnapshot() {
    // don't send messages while jumping or while paused
    // DEV: So that when we are jumping to an old snapshot it
    // wouldn't think we want to create new snapshots
    if (mode.jumping || mode.paused) return;
    //* Deep copies only the state of each component and creates a new tree
    const payload = snap.tree.getCopy();
    // console.log('payload', payload);
    window.postMessage({
      action: 'recordSnap',
      payload,
    });
  }

  function changeSetState(component) {
    // check that setState hasn't been changed yet
    //* This linkedFiberChanged key is added at the end of the body of this function
    //? Is there an alternative, simpler way to check this rather than adding a new property? What else would be unique to a modified setState method?
    if (component.setState.linkFiberChanged) return;
    // make a copy of setState
    //* A copy of setState is made so that we still have access to the original functionality of React setState.
    const oldSetState = component.setState.bind(component);
    //* Bind is necessary so that it maintains its relationship to the component. 
    // ! console.log(component.setState, 'setState Definition')  // Uncomment this line to see the definition of setState

    // replace component's setState so developer doesn't change syntax
    // component.setState = newSetState.bind(component);
    component.setState = (state, callback = () => {}) => {
      //* Callback is anonymous function that returns undefined by default. 
      //? Will this empty annonymous function pass CI testing?  
      // don't do anything if state is locked
      // UNLESS we are currently jumping through time
      //? Can we move this if statement to the top of the body of the setState method
      if (mode.locked && !mode.jumping) return;
      // continue normal setState functionality, except add sending message middleware
      //? Can we refactor this to be similar to changeUseState? (where we just pass the parameters into oldSetState)
      oldSetState(state, () => {
        //* This anonymous function definition is passed into the original setState method as a callback.
        updateSnapShotTree();
        sendSnapshot();
        //* The snapshotTree is updated and sent before the callback is invoked. 
        callback.bind(component)();
      });
    };
    component.setState.linkFiberChanged = true;
  }

  function changeUseState(component) {
    if (component.queue.dispatch.linkFiberChanged) return;
    // store the original dispatch function definition
    const oldDispatch = component.queue.dispatch.bind(component.queue);
    // redefine the dispatch function so we can inject our code
    //* This is similar in concept to setState but for the useState hook
    component.queue.dispatch = (fiber, queue, action) => {
      // don't do anything if state is locked
      //? Can we move this if statement to the top of the body of the changeUseState method
        //* We can't make any changes here because we are already at the top of the body of the useState method.
      if (mode.locked && !mode.jumping) return;
      oldDispatch(fiber, queue, action);
      // setTimeout(() => {
      updateSnapShotTree();
      sendSnapshot();
      // }, 100);
    };
    component.queue.dispatch.linkFiberChanged = true;
  }

  // Helper function to traverse through the memoized state
  // TODO: WE NEED TO CLEAN IT UP A BIT
  function traverseHooks(memoizedState) {
    // Declare variables and assigned to 0th index and an empty object, respectively
    //* memoized stores each state value
    const memoized = {};
    let index = 0;
    //* astHooks starts as an object with keys representing the useState hook ie: {_useState: "count", _useState2: "setCount"}
    astHooks = Object.values(astHooks);
    //* We take the values of those keys and create an array of all the values. 

    // while memoizedState is truthy, save the value to the object
    while (memoizedState && memoizedState.queue) {
      // prevents useEffect from crashing on load
      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates
      changeUseState(memoizedState);
      // }
      //? Can we remove the comment below since its a duplicate of the code? 
      // memoized[astHooks[index]] = memoizedState.memoizedState;
      //? astHooks seems to traverse in a way similar to this method - is this why the values always match?
        //* Yes that appears to be the case. astHooks gets the variable names, while this method gets the saved variable values. 
      //? Is there a way to do both traversals simultaneously? [similar in a sense to the way we invoke changeUseState while we are traversing rather than doing a completely different traversal for changeUseState]
        //* Since ast first has to parse the JSX, there is a benefit to keeping everything separated for simplicity. 
      //* Since astHooks is an array of useState return values and we only want the first element [the current state value] from each instance of useState: 
      
      memoized[astHooks[index]] = memoizedState.memoizedState;
      // Reassign memoizedState to its next value
      //! See note below and check ESLint
      //? We should consider at least reassigning memoizedState to a different variable name by reference. 
      //? Should we create a copy of the memoized state object and then manipulate that version?
      //* The next line is what allows us to traverse to find the next state. 
      memoizedState = memoizedState.next;
      // Increment the index by 2
      //* Since we know that the useState returns an array with 2 values, we increment by 2 to skip to he next instance of useState
      index += 2;
    }
    return memoized;
  }

  function createTree(currentFiber, tree = new Tree('root')) {
    //* When this function is invoked from another function, a new tree is created where the state property of the component key has a key called "root"
    //* The recursive iterations have this tree passed into the recursive functions. 
    //* The recursive runs: 1. Create a tree where the component key is equal to the stateNode. 2. Push that tree into the children array of the original tree 3. Saves the tree that has become a new child as nextTree
    //* This is a recursive function, so adding a console.log here will result in numerous invocations

    //* The next line is the base case for the recursion. If we have reached the linkedList, currentFiber will be null and we can simply return the updated tree that has been updated with all of the children. 
    if (!currentFiber) return tree;

    const {
      sibling,
      stateNode,
      child,
      memoizedState,
      elementType,
    } = currentFiber;
    //* memoizedState is null until numbers are pressed into the calculator. The number in the results window of the calculator is what is memoized.

    //! Important to determine
    //? Why do we initialize nextTree as tree, but then we assign tree an unrelated value (the evaluated result of invoking tree's appendChild method)
    let nextTree = tree;
    // check if stateful component
    if (stateNode && stateNode.state) {
      //* In the calculator app there is only 1 stateful component, so there is only 1 stateNode that have a value that is not null/undefined.
      // add component to tree
      nextTree = tree.appendChild(stateNode);

      // change setState functionality
      changeSetState(stateNode);
      //? Is there any reason for invoking this function below the invocation of appendChild? 
      //? Is the location interchangable (can be placed at the top of the body if desired)?  
        //* Moving this method upwards seems like a logical thing to try
    }
    // Check if the component uses hooks
    // console.log("memoizedState", memoizedState);

    //? It seems that components using the setState method will have stateNodes and functional components using useState will have memoizedState. -
    //? Are there any other properties we can use to determine what hooks / lifecycle methods are in use? Any potential bugs that using these identifiers could cause, or are they 100% accurate?
      //* memoized state is correct for useState
      //? What else does can it be used for? What is used for useContext etc. 
    if (
      memoizedState &&
      Object.hasOwnProperty.call(memoizedState, 'baseState')
      //* This syntax for object.hasOwnProperty is used to bind the Object prototype's hasOwnProperty method to the memoizedState object and invoke it with an argument of baseState. 
      //? Is there any situation when memoizedState would have a property called hasOwnProperty?
        //* This is just good practice since we don't know what could be in the prototype of a given object. 
      //? Why do we need to check for a memoizedState key and a baseState property as well?

    ) {
      // 'catch-all' for suspense elements (experimental)
      //? Does this mean that suspense mode is not supported? What other identifiers can we use for suspense elements
      if (typeof elementType.$$typeof === 'symbol') return;
      // Traverse through the currentFiber and extract the getters/setters
      //* ElementType in the calculator after clicking: The function defintion of the functional component with the useState hook.
      //* astHooks is declared in the body of the parent function, and it is used by traverseHooks as well
      //* astHooks is formatted like this: {_useState: "count", _useState2: "setCount", _useState3: "test", _useState4: "test2"} [the return values of useState are stored as the values of the numbered keys. Have to move forward my 2 keys to get the next instance of useState]
      //? Can we refactor by passing necessary information into functions rather than storing them globally for the other methods?
      astHooks = astParser(elementType);
      //* astHooks format: {_useState: "count", _useState2: "setCount", _useState3: "test", _useState4: "test2"}
      saveState(astHooks);
      //* saving the state is done in support of timeJump.js
      // Create a traversed property and assign to the evaluated result of
      // invoking traverseHooks with memoizedState
      //* .traversed has all of the current state values stored inside of an object. 
      memoizedState.traversed = traverseHooks(memoizedState);
      nextTree = tree.appendChild(memoizedState);
    }
    //* First parameter of createTree is the currentFiber. That's why we pass in the sibling or child properties from the currentFiber object. 
    //* The second parameter is the tree which has the children array in the constructor that we will push memoized state etc into. 

    // iterate through siblings
    createTree(sibling, tree);
    // iterate through children
    //* nextTree is the return value of the appendChild method.
    createTree(child, nextTree);

    return tree;
  }
  // runs when page initially loads
  // but skips 1st hook click
  async function updateSnapShotTree() {
    let current;
    // if concurrent mode, grab current.child'
    if (concurrent) {
      // we need a way to wait for current child to populate
      //? Why is it 400ms?
      const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve(fiberRoot.current.child), 400);
      });

      current = await promise;
      //? Why do we assign a value to current immediately when that value will be replaced after 400ms? Do we need the value immediately, do we need the value after 400ms, or do we need to save a value and then update it after 400ms?
      //? It seems like we may only need one or the other?
      current = fiberRoot.current.child;
    } else {
      current = fiberRoot.current;
    }

    //* The fiberNode is passed into createTree as an argument
    //* The return value of createTree is assigned to the snapShot object in index.js
    snap.tree = createTree(current);
  }

  return async container => {
    //* This is the function definition that is returned. 
    //* This function takes 1 argument (called container). The argument is the root HTML element that React attaches itself to. 
    //* For example: const root = document.getElementById('root');

    //! console.log(container._reactRootContainer)
    //? In Concurrent Mode, the instructions say to invoke ReactDOM.createRoot. This would cause the container passed into Reactime to be similar to _reactRootContainer in that it would have an _internalRoot property.
    //? Is this done because it is a technical requirement of concurrent mode, or is it just done so that this if statement can have this particular logic?
    //? If the answer to the second question is yes, we may be able to refactor by adding a second parameter to the function. There may also be another property in _internalRoot that we could use in order to optimize everything.    
    if (container._internalRoot) {
      fiberRoot = container._internalRoot;
      concurrent = true;
    } else {
      const {
        _reactRootContainer: { _internalRoot },
        _reactRootContainer,
      } = container;
      // only assign internal root if it actually exists
      //? What would happen if the internal root didn't exist? Why wouldn't it exist? (do we need the _reactRootContainer part of the OR operator)
      //* fiberRoot is stored at the top of the body of the linkFiber method. We update it every time the function is invoked. 
      fiberRoot = _internalRoot || _reactRootContainer;
    }

    await updateSnapShotTree();
    // send the initial snapshot once the content script has started up
    //? What happens if the contentScript is started before the snapshot tree is updated?
    window.addEventListener('message', ({ data: { action } }) => {
      if (action === 'contentScriptStarted') sendSnapshot();
    });
  };
};
