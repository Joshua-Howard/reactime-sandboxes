/* eslint-disable no-underscore-dangle */
/* eslint-disable func-names */
/* eslint-disable no-use-before-define */
/* eslint-disable no-param-reassign */
// links component state tree to library
// changes the setState method to also update our snapshot
const Tree = require('./tree');
const astParser = require('./astParser');
const { saveState } = require('./masterState');

  //* Snap is reference to the snapShot object from index.js
module.exports = (snap, mode) => {
  //* This is the beginning of the body of the function definition that is exported

  let fiberRoot = null;
  let astHooks;
  let concurrent = false; // flag to check if we are in concurrent mode

  function sendSnapshot() {
    // don't send messages while jumping or while paused
    // DEV: So that when we are jumping to an old snapshot it
    // wouldn't think we want to create new snapshots
    if (mode.jumping || mode.paused) return;
    const payload = snap.tree.getCopy();
    // console.log('payload', payload);
    window.postMessage({
      action: 'recordSnap',
      payload,
    });
  }

  function changeSetState(component) {
    // check that setState hasn't been changed yet
    //* This linkedFiberChanged key is added at the end of the body of this function
    //? Is there an alternative, simpler way to check this rather than adding a new property? What else would be unique to a modified setState method?
    if (component.setState.linkFiberChanged) return;
    // make a copy of setState
    //* A copy of setState is made so that we still have access to the original functionality of React setState.
    const oldSetState = component.setState.bind(component);
    //* Bind is necessary so that it maintains its relationship to the component. 
    // ! console.log(component.setState, 'setState Definition')  // Uncomment this line to see the definition of setState

    // replace component's setState so developer doesn't change syntax
    // component.setState = newSetState.bind(component);
    component.setState = (state, callback = () => {}) => {
      //* Callback is anonymous function that returns undefined by default. 
      //? Will this empty annonymous function pass CI testing?  
      // don't do anything if state is locked
      // UNLESS we are currently jumping through time
      if (mode.locked && !mode.jumping) return;
      // continue normal setState functionality, except add sending message middleware
      oldSetState(state, () => {
        //* This anonymous function definition is passed into the original setState method as a callback.
        updateSnapShotTree();
        sendSnapshot();
        //* The snapshotTree is updated and sent before the callback is invoked. 
        callback.bind(component)();
      });
    };
    component.setState.linkFiberChanged = true;
  }

  function changeUseState(component) {
    if (component.queue.dispatch.linkFiberChanged) return;
    // store the original dispatch function definition
    const oldDispatch = component.queue.dispatch.bind(component.queue);
    // redefine the dispatch function so we can inject our code
    component.queue.dispatch = (fiber, queue, action) => {
      // don't do anything if state is locked
      if (mode.locked && !mode.jumping) return;
      oldDispatch(fiber, queue, action);
      // setTimeout(() => {
      updateSnapShotTree();
      sendSnapshot();
      // }, 100);
    };
    component.queue.dispatch.linkFiberChanged = true;
  }

  // Helper function to traverse through the memoized state
  // TODO: WE NEED TO CLEAN IT UP A BIT
  function traverseHooks(memoizedState) {
    // Declare variables and assigned to 0th index and an empty object, respectively
    const memoized = {};
    let index = 0;
    astHooks = Object.values(astHooks);
    // while memoizedState is truthy, save the value to the object
    while (memoizedState && memoizedState.queue) {
      // prevents useEffect from crashing on load
      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates
      changeUseState(memoizedState);
      // }
      // memoized[astHooks[index]] = memoizedState.memoizedState;
      memoized[astHooks[index]] = memoizedState.memoizedState;
      // Reassign memoizedState to its next value
      memoizedState = memoizedState.next;
      // Increment the index by 2
      index += 2;
    }
    return memoized;
  }

  function createTree(currentFiber, tree = new Tree('root')) {
    //* When this function is invoked from another function, a new tree is created where the state property of the component key has a key called "root"
    //* The recursive iterations have this tree passed into the recursive functions. 
    //* The recursive runs: 1. Create a tree where the component key is equal to the stateNode. 2. Push that tree into the children array of the original tree 3. Saves the tree that has become a new child as nextTree
    //* This is a recursive function, so adding a console.log here will result in numerous invocations

    if (!currentFiber) return tree;

    const {
      sibling,
      stateNode,
      child,
      memoizedState,
      elementType,
    } = currentFiber;
    //* memoizedState is null until numbers are pressed into the calculator. The number in the results window of the calculator is what is memoized.

    let nextTree = tree;
    // check if stateful component
    if (stateNode && stateNode.state) {
      //* In the calculator app there is only 1 stateful component, so there is only 1 stateNode that have a value that is not null/undefined.
      // add component to tree
      nextTree = tree.appendChild(stateNode);

      // change setState functionality
      changeSetState(stateNode);
      //? Is there any reason for invoking this function below the invocation of appendChild? 
      //? Is the location interchangable (can be placed at the top of the body if desired)?  
    }
    // Check if the component uses hooks
    // console.log("memoizedState", memoizedState);

    if (
      memoizedState &&
      Object.hasOwnProperty.call(memoizedState, 'baseState')
      //* This syntax for object.hasOwnProperty is used to bind the Object prototype's hasOwnProperty method to the memoizedState object and invoke it with an argument of baseState. 
      //? Is there any situation when memoizedState would have a property called hasOwnProperty?
      //? Why do we need to check for a memoizedState key and a baseState property as well?

    ) {
      // 'catch-all' for suspense elements (experimental)
      if (typeof elementType.$$typeof === 'symbol') return;
      // Traverse through the currentFiber and extract the getters/setters
      astHooks = astParser(elementType);
      saveState(astHooks);
      // Create a traversed property and assign to the evaluated result of
      // invoking traverseHooks with memoizedState
      memoizedState.traversed = traverseHooks(memoizedState);
      nextTree = tree.appendChild(memoizedState);
    }
    // iterate through siblings
    createTree(sibling, tree);
    // iterate through children
    createTree(child, nextTree);

    return tree;
  }
  // runs when page initially loads
  // but skips 1st hook click
  async function updateSnapShotTree() {
    let current;
    // if concurrent mode, grab current.child'
    if (concurrent) {
      // we need a way to wait for current child to populate
      //? Why is it 400ms?
      const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve(fiberRoot.current.child), 400);
      });

      current = await promise;
      //? It seems like we may not need the lines above this that also assign a value to current.
      current = fiberRoot.current.child;
    } else {
      current = fiberRoot.current;
    }

    //* The fiberNode is passed into createTree as an argument
    //* The return value of createTree is assigned to the snapShot object in index.js
    snap.tree = createTree(current);
  }

  return async container => {
    //* This is the function definition that is returned. 
    //* This function takes 1 argument (called container). The argument is the root HTML element that React attaches itself to. 
    //* For example: const root = document.getElementById('root');

    //! console.log(container._reactRootContainer)
    //? In Concurrent Mode, the instructions say to invoke ReactDOM.createRoot. This would cause the container passed into Reactime to be similar to _reactRootContainer in that it would have an _internalRoot property.
    //? Is this done because it is a technical requirement of concurrent mode, or is it just done so that this if statement can have this particular logic?
    //? If the answer to the second question is yes, we may be able to refactor by adding a second parameter to the function. There may also be another property in _internalRoot that we could use in order to optimize everything.    
    if (container._internalRoot) {
      fiberRoot = container._internalRoot;
      concurrent = true;
    } else {
      const {
        _reactRootContainer: { _internalRoot },
        _reactRootContainer,
      } = container;
      // only assign internal root if it actually exists
      //? What would happen if the internal root didn't exist? Why wouldn't it exist? (do we need the _reactRootContainer part of the OR operator)
      //* fiberRoot is stored at the top of the body of the linkFiber method. We update it every time the function is invoked. 
      fiberRoot = _internalRoot || _reactRootContainer;
    }

    await updateSnapShotTree();
    // send the initial snapshot once the content script has started up
    window.addEventListener('message', ({ data: { action } }) => {
      if (action === 'contentScriptStarted') sendSnapshot();
    });
  };
};
