/* eslint-disable no-inner-declarations */
const acorn = require('acorn'); // javascript parser
// eslint-disable-next-line import/newline-after-import
const jsx = require('acorn-jsx');
const JSXParser = acorn.Parser.extend(jsx());
//* Acorn JSX parses JavaScript into Abstract Tree Syntax
//* In this case, it can do things like turn a component into a tree. We can then readily access properties on this tree. 

// Helper function to grab the getters/setters from `elementType`
//* The return value of astHooks is formatted like this: {_useState: "count", _useState2: "setCount", _useState3: "test", _useState4: "test2"} 
module.exports = elementType => {
  //* For useState, this method seems to only be invoked in cases where the FiberNode has a tag of 0 (rather than 5 or others). 
  //* In these cases, elementType is method that is the entire exported component. This seems to correlate to the idea that components are what have state, not other elementTypes like 'div' elements. 
  // Initialize empty object to store the setters and getter
  let ast = JSXParser.parse(elementType);
  //* The hookState object stores all of the use hooks
  //? Is it always in the order that they are declared
    //? This would seem to be the case due to the order of parsing. 
  const hookState = {};

  while (Object.hasOwnProperty.call(ast, 'body')) {
    //* This line is what enables traversal inside of the ast representation of the React functional component
    //? Why do we need to use a while loop? Is there any case when ast.body.body would exist? What is that case?
    ast = ast.body;
    const statements = [];

    /** All module exports always start off as a single 'FunctionDeclaration' type
     * Other types: "BlockStatement" / "ExpressionStatement" / "ReturnStatement"
     * Iterate through AST of every function declaration
     * Check within each function declaration if there are hook declarations */
    //* Body is an array, so we can iterate through it
    ast.forEach(functionDec => {
      //* functionDec is an entire node that is an object: Node {type: "FunctionDeclaration", start: 0, end: 989, id: Node, expression: false, â€¦}
      let body;
      if (functionDec.expression) body = functionDec.expression.body.body;
      else body = functionDec.body.body;
      //? Since the node with type 'program' does not have these properties, should we add a return statement for those cases?

      // Traverse through the function's funcDecs and Expression Statements
      //* body is another array of elements. We are only doing an action here if the type of that array is 'VariableDeclaration'
      /*
      0: Node {type: "ExpressionStatement", start: 26, end: 58, expression: Node}
      1: Node {type: "VariableDeclaration", start: 62, end: 246, declarations: Array(4), kind: "var"}
      2: Node {type: "VariableDeclaration", start: 250, end: 432, declarations: Array(4), kind: "var"}
      3: Node {type: "ReturnStatement", start: 580, end: 987, argument: Node}
      */  
      body.forEach(elem => {
        if (elem.type === 'VariableDeclaration') {
          elem.declarations.forEach(hook => {
            statements.push(hook.id.name);
          });
        }
      });

      //* This is what the array looks like before the next forEach identifies the strings that start with use and creates a key in the hookState object that has a value of the element two indexes to the right.
      //* ["_useState", "_useState2", "count", "setCount", "_useState3", "_useState4", "test", "test2"]
      // Iterate array and determine getter/setters based on pattern
      statements.forEach((el, i) => {
        if (el.match(/_use/)) hookState[el] = statements[i + 2];
      });
    });
  }
  return hookState;
};
