/* eslint-disable no-param-reassign */
// traverses given tree by accessing children through coords array
const { returnState } = require('./masterState');

function traverseTree(tree, coords) {
  let curr = tree;

  coords.forEach(coord => {
    //* curr.children is an object where the keys are numbers
    //? Why does it seem like there is only 1 object in children regardless of how many snapshows have been taken? (hooks)
    //? Are there any hook conditions where this wouldn't be the case
    curr = curr.children[coord];
  });

  return curr;
}

module.exports = (origin, mode) => {
  // recursively change state of tree
  function jump(target, coords = []) {
    //* coords is only used for stateful components
    const originNode = traverseTree(origin.tree, coords);

    // set the state of the origin tree if the component is stateful
    if (originNode.component.setState) {
      originNode.component.setState(target.state, () => {
        // iterate through new children once state has been set
        target.children.forEach((child, i) => {
          jump(child, coords.concat(i));
        });
      });
    } else {
      // if component uses hooks, traverse through the memoize tree
      /*
      //*  originNode.component
      *component:
        memoizedState: 1
        baseState: 1
        queue: {last: {…}, lastRenderedState: 0, dispatch: ƒ, lastRenderedReducer: ƒ}
        baseUpdate: {expirationTime: 1073741823, suspenseConfig: null, eagerState: 1, action: ƒ, eagerReducer: ƒ, …}
        next: {memoizedState: "found it!", baseState: "found it!", queue: {…}, baseUpdate: null, next: null}
        traversed: {count: 1, test: "found it!"}
      */
      let current = originNode.component;
      let index = 0;
      const hooks = returnState();
      /* hooks
      (12) ["count", "setCount", "test", "test2", "count", "setCount", "test", "test2", "count", "setCount", "test", "test2"]
      */

      // while loop through the memoize tree
      //* current.queue must be useful to continue the traversal
      //* We are simultaneously traversing the memoizedState (current) as well as the hooks that we have saved. 
      while (current && current.queue) { // allows time travel with useEffect
        //? Why is target here really the child of the target passed into the parent method
        // * As the while loop continues we increment the index by two to get to the next useState variable in the hooks array (declared above as the return value of useState
        current.queue.dispatch(target.state[hooks[index]]);
        // Reassign the current value
        //* This next line allows traversal
        current = current.next;
        index += 2;
      }
    }
  }

  return target => {
    // setting mode disables setState from posting messages to window
    mode.jumping = true;
    jump(target);
    setTimeout(() => {
      mode.jumping = false;
    }, 100);
    //? Why is it 100ms? 
  };
};
